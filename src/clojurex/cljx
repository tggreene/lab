#!/usr/bin/env bb

;; Inject dependencies into clojure project

(require '[babashka.process :refer [process] :as proc]
         '[clojure.edn :as edn]
         '[clojure.java.io :as io]
         '[clojure.string :as str]
         '[clojure.pprint :as pprint])

(def inject-file
  (format "/tmp/inject-%s.clj" (java.util.UUID/randomUUID)))

(def home-user-file
  (str (System/getenv "HOME") "/.clojure/user.clj"))

(def nrepl-middleware
  ['cider.nrepl/cider-middleware
   'cider.piggieback/wrap-cljs-repl
   'refactor-nrepl.middleware/wrap-refactor])

#_
(def add-main-opts
  [;;"-e" (format "(load-file,\"%s\")" inject-file)
   "-e" (format "(load-file,\"%s\"),(user/load-clj!)" home-user-file)
   "-m" "nrepl.cmdline"
   "--middleware" (str "[" (str/join "," nrepl-middleware) "]")])

(defn pr-str-commas
  [x]
  (-> x
      (pr-str)
      (.replace " " ",")))

(defn add-main-opts-clj
  [aliases]
  ["-e" (pr-str-commas
         (list 'do
               (list 'load-file home-user-file)
               (list 'user/load-clj! (vec aliases))))])

(defn add-main-opts-cljs
  [aliases builds]
  ["-e" (pr-str-commas
         (list 'do
               (list 'load-file home-user-file)
               (list 'user/load-cljs! (vec aliases) (vec builds))))])

(def extra-deps
  {'cider/cider-nrepl {:mvn/version "0.27.2"}
   'com.clojure-goes-fast/clj-memory-meter {:mvn/version "0.1.0"}
   'com.lambdaisland/classpath {:mvn/version "0.0.27"}
   'nrepl/nrepl {:mvn/version "0.8.3"}
   'org.clojars.tggreene/hashp {:mvn/version "0.3.0"}
   'com.github.tggreene/hashc {:local/root "/home/tim/workspaces/github.com/tggreene/hashc"}
   'philoskim/debux {:mvn/version "0.7.8"}
   'refactor-nrepl/refactor-nrepl {:mvn/version "3.1.0"}
   'com.github.tggreene/integrant-repl-autoreload {:mvn/version "0.2.0"}
   'cider/piggieback {:mvn/version "0.5.3"}
   'vlaaad/reveal {:mvn/version "1.3.265"}})

(def extra-deps-cljs
  {'org.slf4j/slf4j-nop {:mvn/version "1.7.30"}})

(def jvm-opts
  ["-Djdk.attach.allowAttachSelf"])

(defn aliases
  "Extracts main aliases"
  [args]
  (when (seq args)
    (-> (filter #(re-matches #"-M(:[\/\w\.]+)+" %) args)
        first
        (str/split #":")
        (->> (drop 1)
             (map keyword)
             (vec)))))

(defn last-alias
  [args]
  (let [alias-arg (first (filter #(re-matches #"-M(:\w+)+" %) args))
        aliases (str/split alias-arg #":")]
    (keyword (last aliases))))

(defn remove-main-m-args
  [main-opts]
  (let [pairs (partition-all 2 main-opts)]
    (apply concat (take-while #(not= "-m" (first %)) pairs))))

(defmacro formstring-old
  [& body]
  (->> body
       (map pr-str)
       (str/join "\n")))

(defmacro formstring
  [resolve-symbols & body]
  (let [resolve-symbols (set resolve-symbols)
        forms (->> body
                   (map (fn [form]
                          (clojure.walk/postwalk
                           (fn [x]
                             (if (contains? resolve-symbols x)
                               (symbol (str "{{" x "}}"))
                               x))
                           form)))
                   (map pr-str)
                   (map #(if-let [matches (re-seq #"\{\{([^\{\}]+)\}\}" %)]
                           (apply list
                                  'format
                                  (str/replace % #"\{\{([^\{\}]+)\}\}" "%s")
                                  (mapv (comp symbol second) matches))
                           %)))]
    `(str/join "\n" [~@forms])))

(defn inject-form
  [aliases]
  (let [aliases (or aliases [])]
    (formstring [aliases]
     (ns inject
       (:require hashp.core
                 debux.core
                 lambdaisland.classpath.watch-deps
                 [integrant-repl-autoreload.core :as igra]
                 #_
                 [nrepl.cmdline :as nc]))
     (println "Loading" *file*)

     ;; Load new deps automatically
     (future
       (lambdaisland.classpath.watch-deps/start! {:aliases aliases}))

     (System/setProperty "vlaaad.reveal.prefs" (str {:font-family "JetBrainsMono Nerd Font"
                                                     :font-size 24}))


     (intern 'user 'start-auto-reset igra/start-auto-reset)
     (intern 'user 'stop-auto-reset igra/stop-auto-reset)

     ;; This can be enabled to boot nrepl (but should come after all other commands are run)
     #_
     (try
       (nc/set-signal-handler! "INT" #'nc/handle-interrupt)
       (nc/dispatch-commands {:middleware ['cider.nrepl/cider-middleware
                                           'refactor-nrepl.middleware/wrap-refactor]})
       (catch clojure.lang.ExceptionInfo ex
         (let [{:keys [::kind ::status]} (ex-data ex)]
           (when (= kind ::exit)
             (#'nc/clean-up-and-exit status))
           (throw ex))))

     (println "Loaded" *file*))))

(defn sublists-n
  [xs n]
  (lazy-seq
   (when (<= n (bounded-count n xs))
     (cons (take n xs) (sublists-n (rest xs) n)))))

(defn list-contains?
  [target test]
  (contains? (set (sublists-n target (count test)))
             test))

(defn update-main-opts
  [main-opts args]
  (let [arg-pairs (partition-all 2 args)]
    (reduce (fn [main-opts arg-pair]
              (cond
                (list-contains? main-opts arg-pair)
                main-opts

                (= "-e" (first arg-pair))
                (concat arg-pair main-opts)

                (= "-m" (first arg-pair))
                (concat main-opts arg-pair)

                :else
                (concat main-opts arg-pair)))
            main-opts
            arg-pairs)))

(defn modify-deps-alias
  [run-mode deps alias extra-deps add-main-opts]
  (update-in deps [:aliases alias]
             (fn [alias-m]
               (cond-> alias-m
                 (#{:run-m :run-a :run-x} run-mode) (update :extra-deps merge extra-deps)
                 (#{:run-m} run-mode) (update :main-opts remove-main-m-args)
                 (#{:run-m} run-mode) (update :main-opts update-main-opts add-main-opts)
                 (#{:run-m} run-mode) (update :main-opts vec)))))

(defn deps-run-type
  [args]
  (let [args-str (str/join " " args)]
    (cond
      (empty? args) :run-m
      (.contains args-str "-M") :run-m
      (.contains args-str "-A") :run-a
      (.contains args-str "-X") :run-x
      (.contains args-str "-T") :run-t)))

(defn main-
  [& args]
  (if (.exists (io/file "deps.edn"))
    (let [cljs? (contains? (set args) "--cljs")
          aliases (aliases args)
          just-args (remove (partial re-matches #"^-.+") args)
          target-alias (or (last aliases) :cljx)
          deps (modify-deps-alias
                (deps-run-type args)
                (edn/read-string (slurp "deps.edn"))
                target-alias
                (if cljs?
                  (merge extra-deps extra-deps-cljs)
                  extra-deps)
                (if cljs?
                  ;; For cljs everything following the aliases are assumed to be build targets
                  (add-main-opts-cljs aliases just-args)
                  (add-main-opts-clj aliases)))
          deps-file (format "/tmp/deps-%s.edn" (java.util.UUID/randomUUID))
          _ (spit deps-file (with-out-str (pprint/pprint deps)))
          args (or (cond->> args
                     cljs? (remove (conj (set just-args) "--cljs")))
                   [(str "-M" target-alias)])
          proc-args (into ["clj" "-Sdeps" deps] args)]
      (println (str "clj -Sdeps " deps-file " " (str/join " " args)))
      @(process proc-args
                {:inherit true
                 :shutdown proc/destroy-tree})
      nil)
    (println "No deps.edn")))

(apply main- *command-line-args*)

;; Local Variables:
;; mode: clojure
;; End:
